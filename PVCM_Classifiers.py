# -*- coding: utf-8 -*-
"""EEL6812 - HW02_PVCM Classifiers.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kxUBTm9vFGhmHPfgjfQpGhsdnv1plYY2
"""

# FLORIDA INTERNATIONAL UNIVERSITY (FIU)
# EEL6812 - ADVANCED TOPICS IN NEURAL NETWORKS (DEEP LEARNING)
# MOLTO, JOAQUIN (PID: 6119985)
# HW ASSIGNMENT #2 - CONVOLUTIONAL NEURAL NETWORKS
# DUE DATE: 04/10/2024

"""# PVCM CLASSIFIERS (1=PANDA,0=NOT PANDA/CAT)"""

# BRING NECESSARY FILES INTO THE SESSION
from google.colab import files
import os, shutil, pathlib
import tensorflow as tf
from tensorflow.keras.preprocessing import image_dataset_from_directory
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout
from tensorflow.keras.callbacks import ModelCheckpoint
from tensorflow.keras.regularizers import l1, l2
from tensorflow.keras import layers
import matplotlib.pyplot as plt
import numpy as np

# INSTALL KAGGLE IF NOT ALREADY INSTALLED AND IMPORT KAGGLE.JSON INTO THE SESSION
!pip install kaggle
files.upload()

# CREATES THE KAGGLE DIRECTORY IN THE SESSION, COPIES JSON FILE OVER, GRANTS PERMISSION USING CHMOD
!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

# USE KAGGLE CLI TO DOWNLOAD THE DATASET
!kaggle datasets download -d ashishsaxena2209/animal-image-datasetdog-cat-and-panda

!unzip -qq animal-image-datasetdog-cat-and-panda.zip

"""**PART I. INITIAL REORGANIZATION OF THE DATA**


*   TRAIN **[TR]** = 700 patterns/samples each
*   VALIDATION **[TT]** = 700 pattern/sample each
*   TESTING **[TS]** = 700 pattern/sample each

Acknowledgement to Dr. Barreto for this portion of the Jupyter Notebook, as his code facilitated the creation of the subdirectories with the split data
"""

# DR. BARRETO'S DATA PREPARATION CODE
original_dir = pathlib.Path('animals')
new_base_dir = pathlib.Path('newanim')
def make_subset(subset_name, start_index, end_index):
  for category in ('cats', 'dogs', 'panda'):
    dir = new_base_dir / subset_name / category
    dirsrc = original_dir / category
    os.makedirs(dir)
    fnames = ['{}_{:05d}.jpg'.format(category, i)
                  for i in range(start_index, end_index)]
    for fname in fnames:
     shutil.copyfile(src=dirsrc / fname , dst=dir / fname)

    #print(fnames)
    #print(dirsrc)
    #print(dir)
# make_subset('train', start_index=0, end_index=1000)
# make_subset('validation', start_index=1000, end_index=1500)
# # make_subset('test', start_index=1500, end_index=2500)

make_subset('train', start_index=1, end_index=701) # will grab first 700 .jpeg files for Cats, Dogs, and Pandas
make_subset('validation', start_index=701, end_index=901) # will grab remaining 200 .jpeg files for Cats, Dogs, and Pandas
make_subset('test', start_index=901, end_index=1001) # will grab last 100 .jpeg files for Cats, Dogs, Pandas (TOTAL: 1,000 FILES PER CLASS)

# verify the 3 subdirectories were created
!ls -l ./newanim/

"""**PART II. DOGS VERSUS PANDAS CLASSIFIER**

Before we start building the Convolutional Neural Network (CNN) and the Fully-Connected or Dense Neural Network, we must remove the cat subdirectories for TR, TT, TS folders
"""

# REMOVE ALL 3 DOG SUBDIRECTORIES FROM THE TRAINING, VALIDATION, AND TESTING FOLDERS
!rm -r ./newanim/train/dogs/
!rm -r ./newanim/validation/dogs/
!rm -r ./newanim/test/dogs/

# ENSURE THE DOG SUBDIRECTORY IS GONE FROM THESE THREE SUBDIRECTORIES
!dir ./newanim/train
!dir ./newanim/validation
!dir ./newanim/test

# NOW, WE HAVE CREATE THE TF (TENSORFLOW) DATASET
train_dataset = image_dataset_from_directory(
	new_base_dir / 'train',
	image_size=(180, 180),
	batch_size=32)
validation_dataset = image_dataset_from_directory(
	new_base_dir / 'validation',
	image_size=(180, 180),
	batch_size=32)
test_dataset = image_dataset_from_directory(
 	new_base_dir / 'test',
  	image_size=(180, 180),
   	batch_size=32)

"""Therefore, our directory structure now looks like this:

![DIRE-TREE_TVT-NOCATS.PNG](data:image/png;base64,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)

**PART II.1 DOGS VERSUS PANDAS CLASSIFIER (pvcm1)**

Develop a first, relatively simple CNN model named pvcm1 to classify Dogs versus Pandas

RESTRICTIONS:


1.   CANNOT USE DROPOUT
2.   CANNOT USE L1 OR L2 NORM PARAMETER REGULARIZATION
3.   CANNOT USE DATA AUGMENTATION

pvcm1 Architecture:

*   2D Convolutional Neural Network (CNN)
**   3x3 Kernels/Filters (32 of them)
**   MaxPool 2D Layer (size 2)
*   2D Convolutional Neural Network (CNN)
**   3x3 Kernels/Filters (32 of them)
**   MaxPool 2D Layer (size 2)
*   2D Convolutional Neural Network (CNN)
**   3x3 Kernels/Filters (32 of them)
**   MaxPool 2D Layer (size 2)
* Flattening Layer (Rank-1 Tensor)
* Fully-Connected/Dense Network (DNN)
** HL01: 128 PE with ReLU activation
** OL: 1 PE with Sigmoid activation
"""

# PREPROCESS THE IMAGES TO HAVE CONSISTENT DIMENSIONS AND PERFORM PIXEL NORMALIZATION

# while the instructions impede the use of neuron dropout, L1/L2 weight regularization, and data augmentation for the first model pvcm1
# I will perform pixel-wise normalization by dividing by 255

# IMAGE PREPROCESSING FUNCTION
def normalize_image(image,label):
  return image / 255, label

# APPLY THE PREPROCESSING FUCTION TO THE TF DATASET
train_dataset = train_dataset.map(normalize_image)
validation_dataset = validation_dataset.map(normalize_image)
test_dataset = test_dataset.map(normalize_image)

# DEFINE MODEL ARCHITECTURE FOR pvcm01 USING KERAS SEQUENTIAL API
pvcm1 = Sequential([
    Conv2D(32, (3, 3), activation='relu', input_shape=(180, 180, 3)),
    MaxPooling2D((2, 2)),
    Conv2D(64, (3, 3), activation='relu'),
    MaxPooling2D((2, 2)),
    Conv2D(128, (3, 3), activation='relu'),
    MaxPooling2D((2, 2)),
    Flatten(),
    Dense(128, activation='relu'),
    Dense(1, activation='sigmoid')
])

# COMPILE THE MODEL
pvcm1.compile(optimizer='adam',
              loss='binary_crossentropy',
              metrics=['accuracy'])

# SET UP CALLBACK SO THAT WE CAN RETURN THE MODEL (.KERAS) FILE WHOSE WEIGHTS ACHIEVED THE LOWEST VALIDATION LOSS

# SPECIFY THE PATH TO SAVE THE BEST MODEL
model_save_path = "best_model.keras"

# SET UP THE MODEL_CHECKPOINT_CALLBACK MONITORING THE VAL_LOSS
model_checkpoint_callback = ModelCheckpoint(
    filepath=model_save_path,
    save_best_only=True,
    monitor='val_loss',
    mode='min',
    verbose=1
)

# FIT THE MODEL
history = pvcm1.fit(train_dataset,
                    epochs=50,
                    validation_data=validation_dataset,
                    callbacks=[model_checkpoint_callback])

# PRINT THE MODEL SUMMARY
pvcm1.summary()

# EVALUATE THE MODEL
test_loss, test_accuracy = pvcm1.evaluate(test_dataset)
print(f'Test Loss: {test_loss}')
print(f'Test Accuracy: {test_accuracy}')

def plot_history_until_best_epoch_modified(history):
    # Find the epoch number where the validation loss was minimum; epochs are 1-indexed in the plot
    min_val_loss_epoch = history.history['val_loss'].index(min(history.history['val_loss'])) + 1

    # Prepare the range for plotting
    epochs_range = range(1, min_val_loss_epoch + 1)

    plt.figure(figsize=(12, 4))

    # Plot Accuracy with markers and grid
    plt.subplot(1, 2, 1)
    plt.plot(epochs_range, history.history['accuracy'][:min_val_loss_epoch], 'o-', label='Training Accuracy')  # Circle markers, solid line
    plt.plot(epochs_range, history.history['val_accuracy'][:min_val_loss_epoch], marker='^', linestyle='--', fillstyle='none', label='Validation Accuracy')  # Triangle markers, dashed line
    plt.xlabel('Epoch')
    plt.ylabel('Accuracy')
    plt.title(f'Accuracy up to Best Epoch ({min_val_loss_epoch})')
    plt.legend()
    plt.grid(True)  # Display gridlines

    # Plot Loss with markers and grid
    plt.subplot(1, 2, 2)
    plt.plot(epochs_range, history.history['loss'][:min_val_loss_epoch], 'o-', label='Training Loss')  # Circle markers, solid line
    plt.plot(epochs_range, history.history['val_loss'][:min_val_loss_epoch], marker='^', linestyle='--', fillstyle='none', label='Validation Loss')  # Triangle markers, dashed line
    plt.xlabel('Epoch')
    plt.ylabel('Loss')
    plt.title(f'Loss up to Best Epoch ({min_val_loss_epoch})')
    plt.legend()
    plt.grid(True)  # Display gridlines

    plt.tight_layout()
    plt.show()

# Call the function with the history variable
plot_history_until_best_epoch_modified(history)

# PLOT THE TRAINING AND VALIDATION CURVES

# Prepare the figure
plt.figure(figsize=(12, 4))

# Plot Training and Validation Accuracy
plt.subplot(1, 2, 1)  # 1 row, 2 columns, 1st subplot
plt.plot(history.history['accuracy'], 'o-', label='Training Accuracy')  # Circle markers, solid line for Training
plt.plot(history.history['val_accuracy'], '^', linestyle='--', fillstyle='none', label='Validation Accuracy')  # Triangle markers, dashed line for Validation
plt.title('Model Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend(loc='lower right')
plt.grid(True)  # Display gridlines

# Plot Training and Validation Loss
plt.subplot(1, 2, 2)  # 1 row, 2 columns, 2nd subplot
plt.plot(history.history['loss'], 'o-', label='Training Loss')  # Circle markers, solid line for Training
plt.plot(history.history['val_loss'], marker='^', linestyle='--', fillstyle='none', label='Validation Loss')  # Triangle markers, dashed line for Validation
plt.title('Model Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend(loc='upper right')
plt.grid(True)  # Display gridlines

# Display the plots
plt.tight_layout()
plt.show()

# Assuming test_dataset is batched: (image, label)
predictions = []
labels = []
images = []
for img, label in test_dataset.take(10):  # Adjust the number of batches to suit your dataset size
    pred = pvcm1.predict(img)
    pred = np.round(pred).astype(int).flatten()  # Round predictions to 0 or 1 for binary classification
    predictions.extend(pred)
    labels.extend(label.numpy())
    images.extend(img.numpy())

# Convert lists to arrays for easier manipulation
predictions = np.array(predictions)
labels = np.array(labels)
images = np.array(images)

# Find indices of correct and incorrect predictions
correct_indices = np.where(predictions == labels)[0]
incorrect_indices = np.where(predictions != labels)[0]

# Function to plot images
def plot_images(indices, title):
    plt.figure(figsize=(15, 5))
    for i, idx in enumerate(indices[:3], start=1):  # Plot up to 3 images
        plt.subplot(1, 3, i)
        # Rescale the images back to 0-255 and convert to integers for display
        image_to_display = (images[idx] * 255).astype("uint8")
        plt.imshow(image_to_display)
        plt.title(f"Predicted: {predictions[idx]}, Actual: {labels[idx]}")
        plt.axis("off")
    plt.suptitle(title)
    plt.show()


# Plot correct classifications
plot_images(correct_indices, "Correct Classifications")

# Plot incorrect classifications
plot_images(incorrect_indices, "Incorrect Classifications")

"""**PART II.2 DOGS VERSUS PANDAS CLASSIFIER (pvcm2)**

Develop a second, further improved CNN

RESTRICTIONS:


1.   CAN USE DROPOUT (OK)
2.   CAN USE L1 OR L2 NORM PARAMETER REGULARIZATION (OK)
3.   CANNOT USE DATA AUGMENTATION (NOT OK)

pvcm2 Architecture:

*   2D Convolutional Neural Network (CNN)
** L2 (Ridge) Regularizer of $1 \times10^-3$
**   3x3 Kernels/Filters (32 of them)
**   MaxPool 2D Layer (size 2)
**   Dropout Layer of 0.25 (25%)
*   2D Convolutional Neural Network (CNN)
** L2 (Ridge) Regularizer of $1 \times10^-3$
**   3x3 Kernels/Filters (32 of them)
**   MaxPool 2D Layer (size 2)
**   Dropout Layer of 0.25 (25%)
*   2D Convolutional Neural Network (CNN)
** L2 (Ridge) Regularizer of $1 \times10^-3$
**   3x3 Kernels/Filters (32 of them)
**   MaxPool 2D Layer (size 2)
**   Dropout Layer of 0.25 (25%)
* Flattening Layer (Rank-1 Tensor)
*   Dropout Layer of 0.50 (50%)
* Fully-Connected/Dense Network (DNN)
** HL01: 128 PE with ReLU activation
** OL: 1 PE with Sigmoid activation
"""

# DEFINE MODEL ARCHITECTURE FOR pvcm02 USING KERAS SEQUENTIAL API
pvcm2 = Sequential([
    Conv2D(32, (3, 3), activation='relu', kernel_regularizer=l2(1E-3), input_shape=(180, 180, 3)),
    MaxPooling2D((2, 2)),
    Dropout(0.25), # dropout of 25% after first pooling
    Conv2D(64, (3, 3), activation='relu', kernel_regularizer=l2(1E-3)),
    MaxPooling2D((2, 2)),
    Dropout(0.25), # dropout of 25% after second pooling
    Conv2D(128, (3, 3), activation='relu', kernel_regularizer=l2(1E-3)),
    MaxPooling2D((2, 2)),
    Dropout(0.25), # dropout of 25% after third pooling
    Flatten(),
    Dense(128, activation='relu', kernel_regularizer=l2(1E-3)),
    Dropout(0.5), # dropout of 50% before output
    Dense(1, activation='sigmoid')
])

# COMPILE THE MODEL
pvcm2.compile(optimizer='adam',
              loss='binary_crossentropy',
              metrics=['accuracy'])

# SET UP CALLBACK SO THAT WE CAN RETURN THE MODEL (.KERAS) FILE WHOSE WEIGHTS ACHIEVED THE LOWEST VALIDATION LOSS

# SPECIFY THE PATH TO SAVE THE BEST MODEL
model_save_path = "best_model.keras"

# SET UP THE MODEL_CHECKPOINT_CALLBACK MONITORING THE VAL_LOSS
model_checkpoint_callback = ModelCheckpoint(
    filepath=model_save_path,
    save_best_only=True,
    monitor='val_loss',
    mode='min',
    verbose=1
)

# FIT THE MODEL
history = pvcm2.fit(train_dataset,
                    epochs=50,
                    validation_data=validation_dataset,
                    callbacks=[model_checkpoint_callback])

# PRINT THE MODEL SUMMARY
pvcm2.summary()

# EVALUATE THE MODEL
test_loss, test_accuracy = pvcm2.evaluate(test_dataset)
print(f'Test Loss: {test_loss}')
print(f'Test Accuracy: {test_accuracy}')

def plot_history_until_best_epoch_modified(history):
    # Find the epoch number where the validation loss was minimum; epochs are 1-indexed in the plot
    min_val_loss_epoch = history.history['val_loss'].index(min(history.history['val_loss'])) + 1

    # Prepare the range for plotting
    epochs_range = range(1, min_val_loss_epoch + 1)

    plt.figure(figsize=(12, 4))

    # Plot Accuracy with markers and grid
    plt.subplot(1, 2, 1)
    plt.plot(epochs_range, history.history['accuracy'][:min_val_loss_epoch], 'o-', label='Training Accuracy')  # Circle markers, solid line
    plt.plot(epochs_range, history.history['val_accuracy'][:min_val_loss_epoch], marker='^', linestyle='--', fillstyle='none', label='Validation Accuracy')  # Triangle markers, dashed line
    plt.xlabel('Epoch')
    plt.ylabel('Accuracy')
    plt.title(f'Accuracy up to Best Epoch ({min_val_loss_epoch})')
    plt.legend()
    plt.grid(True)  # Display gridlines

    # Plot Loss with markers and grid
    plt.subplot(1, 2, 2)
    plt.plot(epochs_range, history.history['loss'][:min_val_loss_epoch], 'o-', label='Training Loss')  # Circle markers, solid line
    plt.plot(epochs_range, history.history['val_loss'][:min_val_loss_epoch], marker='^', linestyle='--', fillstyle='none', label='Validation Loss')  # Triangle markers, dashed line
    plt.xlabel('Epoch')
    plt.ylabel('Loss')
    plt.title(f'Loss up to Best Epoch ({min_val_loss_epoch})')
    plt.legend()
    plt.grid(True)  # Display gridlines

    plt.tight_layout()
    plt.show()

# Call the function with the history variable
plot_history_until_best_epoch_modified(history)

# PLOT THE TRAINING AND VALIDATION CURVES

# Prepare the figure
plt.figure(figsize=(12, 4))

# Plot Training and Validation Accuracy
plt.subplot(1, 2, 1)  # 1 row, 2 columns, 1st subplot
plt.plot(history.history['accuracy'], 'o-', label='Training Accuracy')  # Circle markers, solid line for Training
plt.plot(history.history['val_accuracy'], '^', linestyle='--', fillstyle='none', label='Validation Accuracy')  # Triangle markers, dashed line for Validation
plt.title('Model Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend(loc='lower right')
plt.grid(True)  # Display gridlines

# Plot Training and Validation Loss
plt.subplot(1, 2, 2)  # 1 row, 2 columns, 2nd subplot
plt.plot(history.history['loss'], 'o-', label='Training Loss')  # Circle markers, solid line for Training
plt.plot(history.history['val_loss'], marker='^', linestyle='--', fillstyle='none', label='Validation Loss')  # Triangle markers, dashed line for Validation
plt.title('Model Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend(loc='upper right')
plt.grid(True)  # Display gridlines

# Display the plots
plt.tight_layout()
plt.show()

# Assuming test_dataset is batched: (image, label)
predictions = []
labels = []
images = []
for img, label in test_dataset.take(10):  # Adjust the number of batches to suit your dataset size
    pred = pvcm2.predict(img)
    pred = np.round(pred).astype(int).flatten()  # Round predictions to 0 or 1 for binary classification
    predictions.extend(pred)
    labels.extend(label.numpy())
    images.extend(img.numpy())

# Convert lists to arrays for easier manipulation
predictions = np.array(predictions)
labels = np.array(labels)
images = np.array(images)

# Find indices of correct and incorrect predictions
correct_indices = np.where(predictions == labels)[0]
incorrect_indices = np.where(predictions != labels)[0]

# Function to plot images
def plot_images(indices, title):
    plt.figure(figsize=(15, 5))
    for i, idx in enumerate(indices[:3], start=1):  # Plot up to 3 images
        plt.subplot(1, 3, i)
        # Rescale the images back to 0-255 and convert to integers for display
        image_to_display = (images[idx] * 255).astype("uint8")
        plt.imshow(image_to_display)
        plt.title(f"Predicted: {predictions[idx]}, Actual: {labels[idx]}")
        plt.axis("off")
    plt.suptitle(title)
    plt.show()


# Plot correct classifications
plot_images(correct_indices, "Correct Classifications")

# Plot incorrect classifications
plot_images(incorrect_indices, "Incorrect Classifications")

"""**PART II.3 DOGS VERSUS PANDAS CLASSIFIER (pvcm3)**

Develop a third, best CNN

RESTRICTIONS:

NONE

pvcm3 Architecture:

*   2D Convolutional Neural Network (CNN)
** L2 (Ridge) Regularizer of $1 \times10^-4$
**   3x3 Kernels/Filters (32 of them)
**   MaxPool 2D Layer (size 2)
**   Dropout Layer of 0.25 (25%)
*   2D Convolutional Neural Network (CNN)
** L2 (Ridge) Regularizer of $1 \times10^-4$
**   3x3 Kernels/Filters (32 of them)
**   MaxPool 2D Layer (size 2)
**   Dropout Layer of 0.25 (25%)
*   2D Convolutional Neural Network (CNN)
** L2 (Ridge) Regularizer of $1 \times10^-4$
**   3x3 Kernels/Filters (32 of them)
**   MaxPool 2D Layer (size 2)
**   Dropout Layer of 0.25 (25%)
* Flattening Layer (Rank-1 Tensor)
*   Dropout Layer of 0.50 (50%)
* Fully-Connected/Dense Network (DNN)
** HL01: 128 PE with ReLU activation
** OL: 1 PE with Sigmoid activation

Additionally, input data was artificially augmented
"""

data_augmentation = tf.keras.Sequential([
  layers.experimental.preprocessing.RandomFlip("horizontal_and_vertical"),
  layers.experimental.preprocessing.RandomRotation(0.2),
  layers.experimental.preprocessing.RandomZoom(0.2),
  layers.experimental.preprocessing.RandomTranslation(height_factor=0.2, width_factor=0.2),
])

# Assuming train_dataset is your TensorFlow dataset for training
def augment(image, label):
    # Apply the data augmentation to the images
    image = data_augmentation(image)
    return image, label

train_dataset_augmented = train_dataset.map(augment)

import matplotlib.pyplot as plt

for images, _ in train_dataset_augmented.take(1):
    plt.figure(figsize=(10, 10))
    for i in range(9):  # Display 9 images from the batch
        ax = plt.subplot(3, 3, i + 1)
        # Scale the images back to [0, 255] for correct visualization
        plt.imshow((images[i].numpy() * 255).astype("uint8"))
        plt.axis("off")
    plt.show()

# DEFINE MODEL ARCHITECTURE FOR pvcm02 USING KERAS SEQUENTIAL API
pvcm3 = Sequential([
    Conv2D(32, (3, 3), activation='relu', kernel_regularizer=l2(1E-4), input_shape=(180, 180, 3)),
    MaxPooling2D((2, 2)),
    Dropout(0.25), # dropout of 25% after first pooling
    Conv2D(64, (3, 3), activation='relu', kernel_regularizer=l2(1E-4)),
    MaxPooling2D((2, 2)),
    Dropout(0.25), # dropout of 25% after second pooling
    Conv2D(128, (3, 3), activation='relu', kernel_regularizer=l2(1E-4)),
    MaxPooling2D((2, 2)),
    Dropout(0.25), # dropout of 25% after third pooling
    Flatten(),
    Dense(128, activation='relu', kernel_regularizer=l2(1E-4)),
    Dropout(0.5), # dropout of 50% before output
    Dense(1, activation='sigmoid')
])

# COMPILE THE MODEL
pvcm3.compile(optimizer='adam',
              loss='binary_crossentropy',
              metrics=['accuracy'])

# SET UP CALLBACK SO THAT WE CAN RETURN THE MODEL (.KERAS) FILE WHOSE WEIGHTS ACHIEVED THE LOWEST VALIDATION LOSS

# SPECIFY THE PATH TO SAVE THE BEST MODEL
model_save_path = "best_model.keras"

# SET UP THE MODEL_CHECKPOINT_CALLBACK MONITORING THE VAL_LOSS
model_checkpoint_callback = ModelCheckpoint(
    filepath=model_save_path,
    save_best_only=True,
    monitor='val_loss',
    mode='min',
    verbose=1
)

# FIT THE MODEL
history = pvcm3.fit(train_dataset,
                    epochs=50,
                    validation_data=validation_dataset,
                    callbacks=[model_checkpoint_callback])

# PRINT THE MODEL SUMMARY
pvcm3.summary()

# EVALUATE THE MODEL
test_loss, test_accuracy = pvcm3.evaluate(test_dataset)
print(f'Test Loss: {test_loss}')
print(f'Test Accuracy: {test_accuracy}')

def plot_history_until_best_epoch_modified(history):
    # Find the epoch number where the validation loss was minimum; epochs are 1-indexed in the plot
    min_val_loss_epoch = history.history['val_loss'].index(min(history.history['val_loss'])) + 1

    # Prepare the range for plotting
    epochs_range = range(1, min_val_loss_epoch + 1)

    plt.figure(figsize=(12, 4))

    # Plot Accuracy with markers and grid
    plt.subplot(1, 2, 1)
    plt.plot(epochs_range, history.history['accuracy'][:min_val_loss_epoch], 'o-', label='Training Accuracy')  # Circle markers, solid line
    plt.plot(epochs_range, history.history['val_accuracy'][:min_val_loss_epoch], marker='^', linestyle='--', fillstyle='none', label='Validation Accuracy')  # Triangle markers, dashed line
    plt.xlabel('Epoch')
    plt.ylabel('Accuracy')
    plt.title(f'Accuracy up to Best Epoch ({min_val_loss_epoch})')
    plt.legend()
    plt.grid(True)  # Display gridlines

    # Plot Loss with markers and grid
    plt.subplot(1, 2, 2)
    plt.plot(epochs_range, history.history['loss'][:min_val_loss_epoch], 'o-', label='Training Loss')  # Circle markers, solid line
    plt.plot(epochs_range, history.history['val_loss'][:min_val_loss_epoch], marker='^', linestyle='--', fillstyle='none', label='Validation Loss')  # Triangle markers, dashed line
    plt.xlabel('Epoch')
    plt.ylabel('Loss')
    plt.title(f'Loss up to Best Epoch ({min_val_loss_epoch})')
    plt.legend()
    plt.grid(True)  # Display gridlines

    plt.tight_layout()
    plt.show()

# Call the function with the history variable
plot_history_until_best_epoch_modified(history)

# PLOT THE TRAINING AND VALIDATION CURVES

# Prepare the figure
plt.figure(figsize=(12, 4))

# Plot Training and Validation Accuracy
plt.subplot(1, 2, 1)  # 1 row, 2 columns, 1st subplot
plt.plot(history.history['accuracy'], 'o-', label='Training Accuracy')  # Circle markers, solid line for Training
plt.plot(history.history['val_accuracy'], '^', linestyle='--', fillstyle='none', label='Validation Accuracy')  # Triangle markers, dashed line for Validation
plt.title('Model Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend(loc='lower right')
plt.grid(True)  # Display gridlines

# Plot Training and Validation Loss
plt.subplot(1, 2, 2)  # 1 row, 2 columns, 2nd subplot
plt.plot(history.history['loss'], 'o-', label='Training Loss')  # Circle markers, solid line for Training
plt.plot(history.history['val_loss'], marker='^', linestyle='--', fillstyle='none', label='Validation Loss')  # Triangle markers, dashed line for Validation
plt.title('Model Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend(loc='upper right')
plt.grid(True)  # Display gridlines

# Display the plots
plt.tight_layout()
plt.show()

# Assuming test_dataset is batched: (image, label)
predictions = []
labels = []
images = []
for img, label in test_dataset.take(10):  # Adjust the number of batches to suit your dataset size
    pred = pvcm3.predict(img)
    pred = np.round(pred).astype(int).flatten()  # Round predictions to 0 or 1 for binary classification
    predictions.extend(pred)
    labels.extend(label.numpy())
    images.extend(img.numpy())

# Convert lists to arrays for easier manipulation
predictions = np.array(predictions)
labels = np.array(labels)
images = np.array(images)

# Find indices of correct and incorrect predictions
correct_indices = np.where(predictions == labels)[0]
incorrect_indices = np.where(predictions != labels)[0]

# Function to plot images
def plot_images(indices, title):
    plt.figure(figsize=(15, 5))
    for i, idx in enumerate(indices[:3], start=1):  # Plot up to 3 images
        plt.subplot(1, 3, i)
        # Rescale the images back to 0-255 and convert to integers for display
        image_to_display = (images[idx] * 255).astype("uint8")
        plt.imshow(image_to_display)
        plt.title(f"Predicted: {predictions[idx]}, Actual: {labels[idx]}")
        plt.axis("off")
    plt.suptitle(title)
    plt.show()


# Plot correct classifications
plot_images(correct_indices, "Correct Classifications")

# Plot incorrect classifications
plot_images(incorrect_indices, "Incorrect Classifications")

# RANDOM CLASSIFIER
# Assuming test_dataset is batched
num_samples = sum([batch[0].shape[0] for batch in test_dataset])

# Generate random predictions for binary classification
random_predictions_binary = tf.random.uniform(shape=[num_samples], minval=0, maxval=2, dtype=tf.int32)

# Collect actual labels from the dataset
actual_labels = []
for _, label in test_dataset:
    # Flatten the batch of labels into a list
    actual_labels.extend(label.numpy().flatten())  # Use .flatten() to ensure it's a flat list

# Ensure actual_labels is a TensorFlow tensor to match random_predictions_binary
actual_labels = tf.convert_to_tensor(actual_labels, dtype=tf.int32)

# Calculate accuracy
accuracy = tf.reduce_mean(tf.cast(tf.equal(random_predictions_binary, actual_labels), tf.float32))
print(f"Random Classifier Accuracy: {accuracy.numpy()}")